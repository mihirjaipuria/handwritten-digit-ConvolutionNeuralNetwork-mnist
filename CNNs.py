# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13eNiyUY_sWTmMHSJFoVpCUbAYHGWg5_4
"""

import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt

# Load the MNIST dataset
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Display the first image in the training set
plt.imshow(x_train[0], cmap=plt.cm.binary)

# Normalize the pixel values between 0 and 1
x_train = tf.keras.utils.normalize(x_train, axis=1)
x_test = tf.keras.utils.normalize(x_test, axis=1)

# Display the first normalized image
plt.imshow(x_train[0], cmap=plt.cm.binary)

# Print the pixel values of the first normalized image
# print(x_train[0])


import numpy as np
IMG_SIZE = 28
x_trainr = np.array(x_train).reshape(-1, IMG_SIZE, IMG_SIZE, 1)
x_testr = np.array(x_test).reshape(-1, IMG_SIZE, IMG_SIZE, 1)

# Print the dimensions of the training and testing data
print("Training dimensions:", x_trainr.shape)
print("Testing dimensions:", x_testr.shape)

from keras.models import Sequential
from keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Activation, Dropout

# Create the model
model = Sequential()
model.add(Conv2D(64, (3, 3), input_shape=x_trainr.shape[1:]))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), input_shape=x_trainr.shape[1:]))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), input_shape=x_trainr.shape[1:]))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(64))
model.add(Activation("relu"))

model.add(Dense(32))
model.add(Activation("relu"))

model.add(Dense(10))
model.add(Activation("softmax"))

# Print the model summary
# model.summary()

model.compile(loss='sparse_categorical_crossentropy', optimizer="adam", metrics=['accuracy'])

# Train the model
model.fit(x_trainr, y_train, epochs=5, validation_split=0.3)

# Evaluate the model on the test set
test_loss, test_acc = model.evaluate(x_testr, y_test)
print("Loss:", test_loss)
print("Validation accuracy:", test_acc)

# Make predictions on the test set
predictions = model.predict([x_testr])

# Print the predictions for the first test sample
print(predictions)

# Print the predicted label for the first test sample
print("Predicted label:", np.argmax(predictions[0]))

# Display the first test image
plt.matshow(x_test[0])


